//*****************************************************************************************************************
//	STAR CITIZEN TARGET Profile
//		Supports the below combinations of Thrustmaster products:
//		- Thrustmaster Warthog HOTAS (Fully Supported)
//		- Thrustmaster FCS HOTAS (WIP)
//		- Thrustmaster TM16000 Dual sticks (Supported)
//		- Thrustmaster Warthog Dual sticks (WIP)
//		- Thrustmaster Rudder Pedals (Supported)
//		- Thrustmaster MFDs (WIP)
//		- Right Stick (Warthog or TM16000) with Keyboard (WIP)
//		- Left Stick (Warthog or TM16000) with Mouse (WIP)
//		
//	Written by qp
// 		https://robertsspaceindustries.com/citizens/q-p
//
//*****************************************************************************************************************

//DO NOT EDIT THIS FILE UNLESS YOU KNOW WHAT YOU ARE DOING!
//USER-CUSTOMISABLE SETTINGS ARE IN qp_settings.tmh file

int Swap_Roll_Yaw()
{
	if (Roll_Yaw_Swapped==1)
	{
		Roll_Yaw_Swapped=0;
	}else
	{
		Roll_Yaw_Swapped=1;
	}
}

//Augmented Reality Mode (new in 3.0)
int AR_Mode_Engage()
{	
	ActKey(KEYON+DOWN+View_AR_Mode);	
	if (Controller_Warthog_HOTAS==1)
	{
		//KeyAxis(&Throttle, SCX, 0, AXMAP1(2, DXHATDOWN, DXHATUP, 0));
		//KeyAxis(&Throttle, SCY, 0, AXMAP1(2, DXHATLEFT, DXHATRIGHT, 0));
		//MapKey (&Throttle, SC, MOUSE_LEFT);
		MapKey (&Joystick, S2, MOUSE_LEFT);
	}
	if (Controller_TMFR_Pedals==1)
	{}
	if (Controller_TM16000_DualStick==1)
	{
		MapKey (&left, TS2, MOUSE_LEFT);
	}
	AR_Mode=1;	
}

int AR_Mode_Disengage()
{
	ActKey(KEYON+UP+View_AR_Mode);
	if (Controller_Warthog_HOTAS==1)
	{
		//Return S2 to normal
		MapKeyIO(&Joystick, S2, TEMPO(PULSE + Weapons_Lock_Missile, PULSE + Weapons_Lock_Missile, Lock_Multiple_Missiles_Timer), Weapons_Missile);
	}
	if (Controller_TMFR_Pedals==1)
	{}
	if (Controller_TM16000_DualStick==1)
	{
		//Return TS2 to normal
		MapKey (&left, TS2, CHAIN(Movement_Break,Movement_Boost));
	}
	AR_Mode=0;	
}


// FreeLook
		//int FOUFOUTOS, TSOUROUTIKOS;
		int Free_Look_Engage()
		{
			//Push down Free Look key (damn you CIG)
			//ActKey(KEYON+DOWN+View_Free_Look);
				if (Controller_Warthog_HOTAS==1)
				{
					//MapKey (&Throttle, SC, View_Free_Look);
					//..MapAxis (&Throttle, SCY, 0, AXIS_REVERSED, MAP_RELATIVE);
					//MapAxis (&Throttle, SCX, 0, AXIS_REVERSED, MAP_RELATIVE);
					//SetSCurve (&Throttle, SCY, 0, 2*Mouse_Deadzone, 0, Mouse_Curve, Mouse_Scale);
					//SetSCurve (&Throttle, SCX, 0, Mouse_Deadzone, 0, Mouse_Curve, Mouse_Scale);
					//KeyAxis (&Throttle, )
						//KeyAxis(&Throttle, SCY, 0, AXMAP1(LIST(-100,-90,90,100), DXHATDOWN, 0, DXHATUP));
						//KeyAxis(&Throttle, SCX, 0, AXMAP1(LIST(-100,-90,90,100), DXHATLEFT, 0, DXHATRIGHT));
					//KeyAxis(&Device, axis name, layer(s), AXMAP2(number of zones, event1, event 2, event3â€¦);
					//KeyAxis(&Device, axis name, layer(s), AXMAP1(number of zones, up event, down event, optional center event);
					//qp almost working proper KeyAxis(&Throttle, SCX, 0, AXMAP1(2, DXHATDOWN, DXHATUP, 0));
					//qp almost working proper KeyAxis(&Throttle, SCY, 0, AXMAP1(2, DXHATLEFT, DXHATRIGHT, 0));
				}
		}
		
		int Free_Look_Disengage()
		{
			ActKey(KEYON+UP+View_Free_Look);
			//MapAxis (&Throttle, SCY, 0, AXIS_REVERSED, MAP_RELATIVE);
			//MapAxis (&Throttle, SCX, 0, AXIS_NORMAL, MAP_RELATIVE);
		}

// 1.0 HUD Interaction - limited usage in 3.0 currently - in 2.6 used only for mouse mode for SC X/Y
//	// 1.1 HUD_Mode_Engage
//		// maps Slew control to Mouse and Click
//		// maps DMS to HUD Screen Focus
//		int HUD_Mode_Engage()
//		{	
//			//ActKey (KEYON + PULSE + HUD_HUDMode);
//			//MapAxis(&Throttle, SCX, MOUSE_X_AXIS, AXIS_NORMAL, MAP_RELATIVE);
//			//MapAxis(&Throttle, SCY, MOUSE_Y_AXIS, AXIS_NORMAL, MAP_RELATIVE);
//			//SetSCurve(&Throttle, SCX, 0, Mouse_Deadzone, 0, Mouse_Curve, Mouse_Scale);
//			//SetSCurve(&Throttle, SCY, 0, Mouse_Deadzone, 0, Mouse_Curve, Mouse_Scale);
//			//ActKey(KEYON+PULSE+HUD_Show_Mouse_Cursor);
//			ActKey(KEYON+DOWN+View_ARMode);
//			//MapKey(&Throttle, SC, MOUSE_LEFT);
//		}	
//		
//	// 1.2 HUD_Mode_Disengage
//		// maps Slew control to Strafe and look behind
//		int HUD_Mode_Disengage()
//		{	
//			//ActKey (KEYON + PULSE + HUD_HUDMode);
//			ActKey(KEYON+UP+View_ARMode);
//			//MapAxis(&Throttle, SCX, DX_XROT_AXIS, AXIS_NORMAL, MAP_ABSOLUTE);
//			//MapAxis(&Throttle, SCY, DX_YROT_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
//			//if (Flight_Mode==1)
//			//{	
//			//			SetSCurve(&Throttle, SCX, 0, 50, 0, 0, 0);
//			//			SetSCurve(&Throttle, SCY, 0, 50, 0, 0, 0);
//			//}	
//			//	else if (Flight_Mode==2)
//			//	{	
//			//			SetSCurve(&Throttle, SCX, 0, 50, 0, 0, 0);
//			//			SetSCurve(&Throttle, SCY, 0, 50, 0, 0, 0);
//			//	}	
//			//	else if (Flight_Mode==3)
//			//	{	
//			//			SetSCurve(&Throttle, SCX, 0, 50, 0, 0, 0);
//			//			SetSCurve(&Throttle, SCY, 0, 50, 0, 0, 0);
//			//	}
//			//ActKey(KEYON+PULSE+HUD_Show_Mouse_Cursor);
//			//MapKeyIO(&Throttle, SC, Flight_Mouse_Move_Mode, Flight_Mouse_Mode_Toggle);
//		}	
//		
	// 1.3 HUD Magic
		// Allows to cycle through HUD tabs
	//	int HUD_INDEX = 0;
	//	int HUD_Cmds[4] = {KEYON + PULSE + HUD_Show_Overview, KEYON + PULSE + HUD_Show_Weapons, KEYON + PULSE + HUD_Show_Power, KEYON + PULSE + HUD_Show_Shields};
// 3.0 Countermeasures
// broken since 2.6.2, need to revise
//Used together with paddle to launch 2 sets of countermeasures
	// 3.1 Flares
		int CMFlare()
		{	
			if(countermeasure) 
				ActKey(KEYON + PULSE + Weapons_Countermeasure_Launch); 
			else 
				ActKey(CHAIN(KEYON + PULSE + Weapons_Countermeasure_Change,	D(Countermeasure_Timer)	,	KEYON + PULSE + Weapons_Countermeasure_Launch));
				countermeasure=1;
		}
	
	// 3.2 Chaff
		int CMChaff()
		{	
			if(countermeasure) 
				ActKey(CHAIN(KEYON + PULSE + Weapons_Countermeasure_Change,	D(Countermeasure_Timer)	,	KEYON + PULSE + Weapons_Countermeasure_Launch)); 
			else
				ActKey(KEYON + PULSE + Weapons_Countermeasure_Launch);
				countermeasure=0;
		}
		
	// 3.3 Flare, Flare, Flare
	// 3.4 Chaff, Chaff, Chaff
	// 3.5 F/C, F/C, F/C
	// 3,6 Launch 3 of whatever is selected
	// keep in mind to toggle the cmflag every time you change countermeasures
	//	int CMAll()
	//	{
	//	//drops 2 each	ActKey(CHAIN(KEYON+PULSE+Weapons_Countermeasure_Launch,D(50),KEYON+PULSE+Weapons_Countermeasure_Change,D(50),KEYON+PULSE+Weapons_Countermeasure_Launch,D(50),KEYON+PULSE+Weapons_Countermeasure_Change,D(50),KEYON+PULSE+Weapons_Countermeasure_Launch,D(50),KEYON+PULSE+Weapons_Countermeasure_Change,D(50),KEYON+PULSE+Weapons_Countermeasure_Launch));
	//		ActKey(CHAIN(KEYON+PULSE+Weapons_Countermeasure_Launch,D(50),KEYON+PULSE+Weapons_Countermeasure_Change,D(50),KEYON+PULSE+Weapons_Countermeasure_Launch));
	//	}

// 4.0 Shields 
	// Shield Management briefly shows Shield HUD when changing shields
	//does not work in 3.0
	int DoShields(int Key_Input)
	{
		//ActKey(KEYON + PULSE + HUD_Show_Shields);
		ActKey(KEYON + Key_Input);
	}

// 5.0 AfterBurner 
	// 5.1 Activates Afterburner
	int AfterBurnerON()
	{
		ActKey(KEYON + Movement_Afterburner);
	}
	
	// 5.2 Deactivates Afterburner
	int AfterBurnerOFF()
	{
		ActKey(Movement_Afterburner);
	}
	
// 5.5 Boost
	// 5.1 Activates Boost
	int BoostON()
	{
		ActKey(KEYON + Movement_Boost);
	}
	
	// 5.2 Deactivates Afterburner
	int BoostOFF()
	{
		ActKey(Movement_Boost);
	}
	
// 6.0 Cycling HUD
//deprecated as of 3.0
	// int CycleHUD(int iOffset)
	// {
	// 	// Controls the HUD tab order in cycling the HUD
	// 	HUD_INDEX = HUD_INDEX + iOffset;
	// 	if(HUD_INDEX < 0)
	// 		HUD_INDEX = 3;
	// 	if(HUD_INDEX > 3)
	// 		HUD_INDEX = 0;
	// 		
	// 	ActKey(HUD_Cmds[HUD_INDEX]);
	// }

// 7.0 HUD Responds to changing shield and power settings
//deprecated as of 3.0
	//int OnHUDCallback(int param)
	//{
	//	// Pressing any of the below buttons will make the HUD flash with relative info and then return to overview
	//	if(Throttle[RDRNRM] | Throttle[MSD] | Throttle[MSU] | Joystick[H3U] | Joystick[H3D] | Joystick[H3L] | Joystick[H3R])
	//		return 0;
	//	// Otherwise, set the HUD back to the Overview
	//	ActKey(KEYON + PULSE + HUD_Show_Overview);
	//	HUD_INDEX = 0;
	//}

// 10.0 Firing Mode TG1 TG2

//Piece of shit nested block 
	int STRAFEAXIS;

	
// 2.0 Advanced IFCS Control Modes
// Currently are 3 Advanced Flight Modes:
//		- Sensitivity 	| Limits all truster output to 50% All controls behave much 'slower' allowing for fine control. Ideal for landings.
//		- Precision		| Provides more precision near the center of the control axis for greater precision in dogfighting. Ideal for normal flying.
//		- Agility		| Provides more precision near the edges of the control axis for faster course changes at sudden movements. Ideal for racing and turret control.
// Combat		| Combines Precision mode for Rotational axis and Agility mode for Translational axis. Ideal for combat.
// based on this command: SetSCurve(&Device, axis name, left_deadzone, center_deadzone, right_deadzone, curve, scale)
	// 2.1 Precision
		int Transition_Mode()
		{
				//Handles transition between states to ensure expected behaviour when swithcing between modes
				AfterBurnerOFF();
				BoostOFF();
				ActKey(KEYON + PULSE + Movement_Throttle_Zero);
				D ();
				ActKey(KEYON + PULSE + Movement_Throttle_Zero);
				// ActKey (KEYON + PULSE + Flight_Mode_Switch);	
		}
		
		int Precision_Mode()
		{				
			if (Controller_Warthog_HOTAS==1)
			{//code to change axis assignments
				MapAxis(&Throttle, THR_RIGHT, DX_THROTTLE_AXIS, AXIS_NORMAL, MAP_ABSOLUTE); //0-100 on right throttle
			//code to change the curves on the axis
				//Warthog HOTAS
					//Set Throttle to 0-100 at 98% of physical travel
					SetJCurve(&Throttle, THR_RIGHT, 98, 100);
					// Make Afterburner Turn on when Throttle >98%
					KeyAxis(&Throttle, THR_RIGHT, 0, AXMAP1(LIST(0,98,100,100), 0, EXEC("AfterBurnerOFF();"), EXEC("AfterBurnerON();")));
					SetSCurve(&Joystick, JOYX, 0, 0, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					SetSCurve(&Joystick, JOYY, 0, 0, 0, Precision_Mode_Curve, Precision_Mode_Scale); //need to test with asymetrical curves Y>X
					//SetSCurve(&Throttle, THR_FC, 0, 0, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					SetSCurve(&Throttle, THR_LEFT, 0, Left_Throttle_Deadzone, 0, Precision_Mode_Curve, Precision_Mode_Scale);
			}
			if (Controller_TMFR_Pedals==1)
			{//Rudder Pedals
					SetSCurve(&TFRPRudder, TRUDDER, 0, Rudder_Deadzone, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					SetSCurve(&TFRPRudder, TRPRIGHT, 0, 0, 0, 2*Precision_Mode_Curve, 2*Precision_Mode_Scale);
					SetSCurve(&TFRPRudder, TRPLEFT, 0, 0, 0, 2*Precision_Mode_Curve, 2*Precision_Mode_Scale);
			}
			if (Controller_TM16000_DualStick==1)
			{//Dual Stick - Right
					SetSCurve(&right, JOYX, 0, Right_Stick_X_Deadzone, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					SetSCurve(&right, JOYY, 0, Right_Stick_Y_Deadzone, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					SetSCurve(&right, RUDDER, 0, Right_Stick_Rudder_Deadzone, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					//SetSCurve(&right, THR, 0, 0, 0, Precision_Mode_Curve, Precision_Mode_Scale);
				//Dual Stick - Left
					SetSCurve(&left, JOYX, 0, Left_Stick_X_Deadzone, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					SetSCurve(&left, JOYY, 0, Left_Stick_Y_Deadzone, 0, Precision_Mode_Curve/2, Precision_Mode_Scale);
					SetSCurve(&left, RUDDER, 0, Left_Stick_Rudder_Deadzone, 0, Precision_Mode_Curve, Precision_Mode_Scale);
					//Set Throttle to 0-100 at 98% of physical travel
					SetJCurve(&left, THR, 98, 100);
					// Make Afterburner Turn on when Throttle >98%
					KeyAxis(&left, THR, 0, AXMAP1(LIST(0,2,100), EXEC("AfterBurnerOFF();"), EXEC("AfterBurnerON();"), 0));
			}
			//code to handle transition
				Transition_Mode();
				Flight_Mode=1;
			}	
	
	// 2.2 Sensitivity
		int Sensitivity_Mode()
			{				
			if (Controller_Warthog_HOTAS==1)
			{//code to change axis assignments
				MapAxis(&Throttle, THR_RIGHT, DX_YROT_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
				//MapAxis(&Throttle, THR_FC, DX_THROTTLE_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
			//code to change the curves on the axis
				//Warthog HOTAS
					//Reset Curve for Right Throttle
					SetJCurve(&Throttle, THR_RIGHT, 0, 100);
					//Disable AB on axis
					KeyAxis(&Throttle, THR_RIGHT, '', 0);
					SetSCurve(&Joystick, JOYX, 0, 0, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					SetSCurve(&Joystick, JOYY, 0, 0, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					//SetSCurve(&Throttle, THR_FC, 0, 0, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					SetSCurve(&Throttle, THR_LEFT, 0, 2*Left_Throttle_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					SetSCurve(&Throttle, THR_RIGHT, 0, 2*Right_Throttle_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
			}
			if (Controller_TMFR_Pedals==1)
			{//Rudder Pedals
					SetSCurve(&TFRPRudder, TRUDDER, 0, 2*Rudder_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					SetSCurve(&TFRPRudder, TRPRIGHT, 0, 0, 0, 2*Sensitivity_Mode_Curve, 2*Sensitivity_Mode_Scale);
					SetSCurve(&TFRPRudder, TRPLEFT, 0, 0, 0, 2*Sensitivity_Mode_Curve, 2*Sensitivity_Mode_Scale);
			}			
			if (Controller_TM16000_DualStick==1)
			{//Dual Stick - Right
					SetSCurve(&right, JOYX, 0, Right_Stick_X_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					SetSCurve(&right, JOYY, 0, Right_Stick_Y_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					SetSCurve(&right, RUDDER, 0, Right_Stick_Rudder_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					//SetSCurve(&right, THR, 0, 0, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
				//Dual Stick - Left
					SetSCurve(&left, JOYX, 0, 2*Left_Stick_X_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					SetSCurve(&left, JOYY, 0, 2*Left_Stick_Y_Deadzone, 0, Sensitivity_Mode_Curve/2, Sensitivity_Mode_Scale);
					SetSCurve(&left, RUDDER, 0, 2*Left_Stick_Rudder_Deadzone, 0, Sensitivity_Mode_Curve, Sensitivity_Mode_Scale);
					//Set Throttle to 0-100 at 98% of physical travel
					SetJCurve(&left, THR, 98, 100);
					// Make Afterburner Turn on when Throttle >98%
					KeyAxis(&left, THR, 0, AXMAP1(LIST(0,2,100), EXEC("AfterBurnerOFF();"), EXEC("AfterBurnerON();"), 0));
			}
			//code to handle transition
				Transition_Mode();
				Flight_Mode=2;
			}	
	int Combat_Mode()
			{				
			if (Controller_Warthog_HOTAS==1)
			{//code to change axis assignments
				MapAxis(&Throttle, THR_RIGHT, DX_YROT_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
				//MapAxis(&Throttle, THR_FC, DX_THROTTLE_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
			//code to change the curves on the axis
				//Warthog HOTAS
					//Reset Curve for Right Throttle
					SetJCurve(&Throttle, THR_RIGHT, 0, 100);
					//Disable AB on axis
					KeyAxis(&Throttle, THR_RIGHT, '', 0);
					SetSCurve(&Joystick, JOYX, 0, 0, 0, Combat_Mode_Rotation_Curve, Combat_Mode_Rotation_Scale);
					SetSCurve(&Joystick, JOYY, 0, 0, 0, Combat_Mode_Rotation_Curve, Combat_Mode_Rotation_Scale);
					SetSCurve(&Throttle, THR_LEFT, 0, Left_Throttle_Deadzone/2, 0, Combat_Mode_Translation_Curve, Combat_Mode_Translation_Scale);
					SetSCurve(&Throttle, THR_RIGHT, 0, Right_Throttle_Deadzone/2, 0, Combat_Mode_Translation_Curve, Combat_Mode_Translation_Scale);
			}
			if (Controller_TMFR_Pedals==1)
			{//Rudder Pedals
					SetSCurve(&TFRPRudder, TRUDDER, 0, Rudder_Deadzone/2, 0, Combat_Mode_Rotation_Curve, Combat_Mode_Rotation_Scale);
					SetSCurve(&TFRPRudder, TRPRIGHT, 0, 0, 0, 2*Combat_Mode_Translation_Curve, 2*Combat_Mode_Translation_Scale);
					SetSCurve(&TFRPRudder, TRPLEFT, 0, 0, 0, 2*Combat_Mode_Translation_Curve, 2*Combat_Mode_Translation_Scale);
			}			
			if (Controller_TM16000_DualStick==1)
			{//Dual Stick - Right
					SetSCurve(&right, JOYX, 0, Right_Stick_X_Deadzone, 0, Combat_Mode_Rotation_Curve, Combat_Mode_Rotation_Scale);
					SetSCurve(&right, JOYY, 0, Right_Stick_Y_Deadzone, 0, Combat_Mode_Rotation_Curve, Combat_Mode_Rotation_Scale);
					SetSCurve(&right, RUDDER, 0, Right_Stick_Rudder_Deadzone, 0, Combat_Mode_Rotation_Curve, Combat_Mode_Rotation_Scale);
					//SetSCurve(&right, THR, 0, 0, 0, Combat_Mode_Curve, Combat_Mode_Scale);
				//Dual Stick - Left
					SetSCurve(&left, JOYX, 0, Left_Stick_X_Deadzone/2, 0, Combat_Mode_Translation_Curve, Combat_Mode_Translation_Scale);
					SetSCurve(&left, JOYY, 0, Left_Stick_Y_Deadzone/2, 0, Combat_Mode_Translation_Curve, Combat_Mode_Translation_Scale);
					SetSCurve(&left, RUDDER, 0, Left_Stick_Rudder_Deadzone/2, 0, Combat_Mode_Translation_Curve, Combat_Mode_Translation_Scale);
					//Set Throttle to 0-100 at 98% of physical travel
					SetJCurve(&left, THR, 98, 100);
					// Make Afterburner Turn on when Throttle >98%
					KeyAxis(&left, THR, 0, AXMAP1(LIST(0,2,100), EXEC("AfterBurnerOFF();"), EXEC("AfterBurnerON();"), 0));
			}
			//code to handle transition
				Transition_Mode();
				Flight_Mode=4;
			}
	// 2.3 Agility
		int Agility_Mode()
			{	
			if (Controller_Warthog_HOTAS==1)
			{//code to change axis assignments
				MapAxis(&Throttle, THR_RIGHT, DX_YROT_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
				//MapAxis(&Throttle, THR_FC, DX_THROTTLE_AXIS, AXIS_REVERSED, MAP_ABSOLUTE);
			//code to change the curves on the axis
				//Warthog HOTAS
					//Reset Curve for Right Throttle
					SetJCurve(&Throttle, THR_RIGHT, 0, 100);
					//Disable AB on axis
					KeyAxis(&Throttle, THR_RIGHT, '', 0);
					SetSCurve(&Joystick, JOYX, 0, 0, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&Joystick, JOYY, 0, 0, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					//SetSCurve(&Throttle, THR_FC, 0, 0, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&Throttle, THR_LEFT, 0, Left_Throttle_Deadzone/2, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&Throttle, THR_RIGHT, 0, Right_Throttle_Deadzone/2, 0, Agility_Mode_Curve, Agility_Mode_Scale);
			}
			if (Controller_TMFR_Pedals==1)
			{//Rudder Pedals
					SetSCurve(&TFRPRudder, TRUDDER, 0, Rudder_Deadzone/2, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&TFRPRudder, TRPRIGHT, 0, 0, 0, 2*Agility_Mode_Curve, 2*Agility_Mode_Scale);
					SetSCurve(&TFRPRudder, TRPLEFT, 0, 0, 0, 2*Agility_Mode_Curve, 2*Agility_Mode_Scale);
			}
			if (Controller_TM16000_DualStick==1)
			{//Dual Stick - Right
					SetSCurve(&right, JOYX, 0, Right_Stick_X_Deadzone, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&right, JOYY, 0, Right_Stick_Y_Deadzone, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&right, RUDDER, 0, Right_Stick_Rudder_Deadzone, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					//SetSCurve(&right, THR, 0, 0, 0, Agility_Mode_Curve, Agility_Mode_Scale);
				//Dual Stick - Left
					SetSCurve(&left, JOYX, 0, Left_Stick_X_Deadzone, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&left, JOYY, 0, Left_Stick_Y_Deadzone, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					SetSCurve(&left, RUDDER, 0, Left_Stick_Rudder_Deadzone, 0, Agility_Mode_Curve, Agility_Mode_Scale);
					//Set Throttle to 0-100 at 98% of physical travel
					SetJCurve(&left, THR, 98, 100);
					// Make Afterburner Turn on when Throttle >98%
					KeyAxis(&left, THR, 0, AXMAP1(LIST(0,2,100), EXEC("AfterBurnerOFF();"), EXEC("AfterBurnerON();"), 0));
			}
			// code to handle transition
				Transition_Mode();
				Flight_Mode=3;
			}	

	

// End of File
// qp
// .